{"ast":null,"code":"var LINEAR_ANIMATION = 'linear';\nvar VALID_SWIPE_DISTANCE = 50;\nvar TRANSITION_END = 'transitionend';\nvar abs = Math.abs;\nvar EVENT_OPTIONS = {\n  passive: false\n};\n\nfunction translate(to, moveX, percentatge) {\n  if (percentatge === void 0) {\n    percentatge = 100;\n  }\n\n  var translation = to * percentatge * -1;\n  var x = moveX ? \"calc(\" + translation + \"% - \" + moveX + \"px)\" : translation + \"%\";\n  return \"translate3d(\" + x + \", 0, 0)\";\n}\n\nfunction clampNumber(x, minValue, maxValue) {\n  return Math.min(Math.max(x, minValue), maxValue);\n}\n\nfunction getTouchCoordinatesFromEvent(e) {\n  return e.targetTouches ? e.targetTouches[0] : e.touches[0];\n}\n/**\n *\n * @param {number} duration\n * @param {string} ease\n * @param {number} index\n * @param {number} x\n * @param {number} percentatge\n */\n\n\nfunction getTranslationCSS(duration, ease, index, x, percentatge) {\n  var easeCssText = ease !== '' ? \"transition-timing-function: \" + ease + \";\" : '';\n  var durationCssText = duration ? \"transition-duration: \" + duration + \"ms;\" : '';\n  return \"\" + easeCssText + durationCssText + \"transform: \" + translate(index, x, percentatge) + \";\";\n}\n\nfunction cleanContainer(container) {\n  // remove all the elements except the last one as it seems to be old data in the HTML\n  // that's specially useful for dynamic content\n  while (container.childElementCount > 1) {\n    container !== null && container.removeChild(container.lastChild);\n  } // tell that the clean is done\n\n\n  return true;\n}\n\nexport default function slidy(containerDOMEl, options) {\n  var doAfterSlide = options.doAfterSlide,\n      doBeforeSlide = options.doBeforeSlide,\n      ease = options.ease,\n      initialSlide = options.initialSlide,\n      numOfSlides = options.numOfSlides,\n      onNext = options.onNext,\n      onPrev = options.onPrev,\n      slidesDOMEl = options.slidesDOMEl,\n      slideSpeed = options.slideSpeed;\n  var items = options.items; // if frameDOMEl is null, then we do nothing\n\n  if (containerDOMEl === null) return; // initialize some variables\n\n  var index = initialSlide;\n  var isScrolling = false;\n  var transitionEndCallbackActivated = false; // event handling\n\n  var deltaX = 0;\n  var deltaY = 0;\n  var touchOffsetX = 0;\n  var touchOffsetY = 0;\n  /**\n   * translates to a given position in a given time in milliseconds\n   *\n   * @param  {number} duration time in milliseconds for the transistion\n   * @param  {string} ease easing css property\n   * @param  {number} x Number of pixels to fine tuning translation\n   */\n\n  function _translate(duration, ease, x) {\n    if (ease === void 0) {\n      ease = '';\n    }\n\n    if (x === void 0) {\n      x = 0;\n    }\n\n    var percentatge = 100 / numOfSlides;\n    slidesDOMEl.style.cssText = getTranslationCSS(duration, ease, index, x, percentatge);\n  }\n  /**\n   * slide function called by prev, next & touchend\n   *\n   * determine nextIndex and slide to next postion\n   * under restrictions of the defined options\n   *\n   * @param {boolean} direction 'true' for right, 'false' for left\n   */\n\n\n  function slide(direction) {\n    var movement = direction === true ? 1 : -1; // calculate the nextIndex according to the movement\n\n    var nextIndex = index + 1 * movement; // nextIndex should be between 0 and items minus 1\n\n    nextIndex = clampNumber(nextIndex, 0, items - 1);\n    goTo(nextIndex);\n  }\n\n  function onTransitionEnd() {\n    if (transitionEndCallbackActivated === true) {\n      _translate(0);\n\n      transitionEndCallbackActivated = false;\n    }\n  }\n\n  function onTouchstart(e) {\n    var coords = getTouchCoordinatesFromEvent(e);\n    isScrolling = undefined;\n    touchOffsetX = coords.pageX;\n    touchOffsetY = coords.pageY;\n  }\n\n  function onTouchmove(e) {\n    // ensure swiping with one touch and not pinching\n    if (e.touches.length > 1 || e.scale && e.scale !== 1) return;\n    var coords = getTouchCoordinatesFromEvent(e);\n    deltaX = coords.pageX - touchOffsetX;\n    deltaY = coords.pageY - touchOffsetY;\n\n    if (typeof isScrolling === 'undefined') {\n      isScrolling = abs(deltaX) < abs(deltaY);\n      if (!isScrolling) document.ontouchmove = function (e) {\n        return e.preventDefault();\n      };\n      return;\n    }\n\n    if (!isScrolling) {\n      e.preventDefault();\n\n      _translate(0, LINEAR_ANIMATION, deltaX * -1);\n    }\n  }\n\n  function onTouchend() {\n    // hack the document to block scroll\n    document.ontouchmove = function () {\n      return true;\n    };\n\n    if (!isScrolling) {\n      /**\n       * is valid if:\n       * -> swipe distance is greater than the specified valid swipe distance\n       * -> swipe distance is more then a third of the swipe area\n       * @isValidSlide {Boolean}\n       */\n      var isValid = abs(deltaX) > VALID_SWIPE_DISTANCE;\n      /**\n       * is out of bounds if:\n       * -> index is 0 and deltaX is greater than 0\n       * -> index is the last slide and deltaX is smaller than 0\n       * @isOutOfBounds {Boolean}\n       */\n\n      var direction = deltaX < 0;\n      var isOutOfBounds = direction === false && index === 0 || direction === true && index === items - 1;\n      /**\n       * If the swipe is valid and we're not out of bounds\n       * -> Slide to the direction\n       * otherwise: go back to the previous slide with a linear animation\n       */\n\n      isValid === true && isOutOfBounds === false ? slide(direction) : _translate(slideSpeed, LINEAR_ANIMATION);\n    } // reset variables with the initial values\n\n\n    deltaX = deltaY = touchOffsetX = touchOffsetY = 0;\n  }\n  /**\n   * public\n   * setup function\n   */\n\n\n  function _setup() {\n    slidesDOMEl.addEventListener(TRANSITION_END, onTransitionEnd);\n    containerDOMEl.addEventListener('touchstart', onTouchstart, EVENT_OPTIONS);\n    containerDOMEl.addEventListener('touchmove', onTouchmove, EVENT_OPTIONS);\n    containerDOMEl.addEventListener('touchend', onTouchend, EVENT_OPTIONS);\n\n    if (index !== 0) {\n      _translate(0);\n    }\n  }\n  /**\n   * public\n   * clean content of the slider\n   */\n\n\n  function clean() {\n    return cleanContainer(slidesDOMEl);\n  }\n  /**\n   * public\n   * @param {number} nextIndex Index number to go to\n   */\n\n\n  function goTo(nextIndex) {\n    // if the nextIndex and the current is the same, we don't need to do the slide\n    if (nextIndex === index) return; // if the nextIndex is possible according to number of items, then use it\n\n    if (nextIndex <= items) {\n      // execute the callback from the options before sliding\n      doBeforeSlide({\n        currentSlide: index,\n        nextSlide: nextIndex\n      }); // execute the internal callback\n\n      nextIndex > index ? onNext(nextIndex) : onPrev(nextIndex);\n      index = nextIndex;\n    } // translate to the next index by a defined duration and ease function\n\n\n    _translate(slideSpeed, ease); // execute the callback from the options after sliding\n\n\n    slidesDOMEl.addEventListener(TRANSITION_END, function cb(e) {\n      doAfterSlide({\n        currentSlide: index\n      });\n      e.currentTarget.removeEventListener(e.type, cb);\n    });\n  }\n  /**\n   * public\n   * prev function: called on clickhandler\n   */\n\n\n  function prev(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    slide(false);\n  }\n  /**\n   * public\n   * next function: called on clickhandler\n   */\n\n\n  function next(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    slide(true);\n  }\n  /**\n   * public\n   * @param {number} newItems Number of items in the slider for dynamic content\n   */\n\n\n  function updateItems(newItems) {\n    items = newItems;\n  }\n  /**\n   * public\n   * destroy function: called to gracefully destroy the slidy instance\n   */\n\n\n  function destroy() {\n    // remove all touch listeners\n    containerDOMEl.removeEventListener('touchstart', onTouchstart, EVENT_OPTIONS);\n    containerDOMEl.removeEventListener('touchmove', onTouchmove, EVENT_OPTIONS);\n    containerDOMEl.removeEventListener('touchend', onTouchend, EVENT_OPTIONS); // remove transition listeners\n\n    slidesDOMEl.removeEventListener(TRANSITION_END, onTransitionEnd);\n  } // trigger initial setup\n\n\n  _setup(); // expose public api\n\n\n  return {\n    clean: clean,\n    destroy: destroy,\n    goTo: goTo,\n    next: next,\n    prev: prev,\n    slide: slide,\n    updateItems: updateItems\n  };\n}","map":{"version":3,"sources":["D:/PhladRian/frontend/node_modules/react-slidy/lib/slidy.js"],"names":["LINEAR_ANIMATION","VALID_SWIPE_DISTANCE","TRANSITION_END","abs","Math","EVENT_OPTIONS","passive","translate","to","moveX","percentatge","translation","x","clampNumber","minValue","maxValue","min","max","getTouchCoordinatesFromEvent","e","targetTouches","touches","getTranslationCSS","duration","ease","index","easeCssText","durationCssText","cleanContainer","container","childElementCount","removeChild","lastChild","slidy","containerDOMEl","options","doAfterSlide","doBeforeSlide","initialSlide","numOfSlides","onNext","onPrev","slidesDOMEl","slideSpeed","items","isScrolling","transitionEndCallbackActivated","deltaX","deltaY","touchOffsetX","touchOffsetY","_translate","style","cssText","slide","direction","movement","nextIndex","goTo","onTransitionEnd","onTouchstart","coords","undefined","pageX","pageY","onTouchmove","length","scale","document","ontouchmove","preventDefault","onTouchend","isValid","isOutOfBounds","_setup","addEventListener","clean","currentSlide","nextSlide","cb","currentTarget","removeEventListener","type","prev","stopPropagation","next","updateItems","newItems","destroy"],"mappings":"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","sourcesContent":["var LINEAR_ANIMATION = 'linear';\nvar VALID_SWIPE_DISTANCE = 50;\nvar TRANSITION_END = 'transitionend';\nvar abs = Math.abs;\nvar EVENT_OPTIONS = {\n  passive: false\n};\n\nfunction translate(to, moveX, percentatge) {\n  if (percentatge === void 0) {\n    percentatge = 100;\n  }\n\n  var translation = to * percentatge * -1;\n  var x = moveX ? \"calc(\" + translation + \"% - \" + moveX + \"px)\" : translation + \"%\";\n  return \"translate3d(\" + x + \", 0, 0)\";\n}\n\nfunction clampNumber(x, minValue, maxValue) {\n  return Math.min(Math.max(x, minValue), maxValue);\n}\n\nfunction getTouchCoordinatesFromEvent(e) {\n  return e.targetTouches ? e.targetTouches[0] : e.touches[0];\n}\n/**\n *\n * @param {number} duration\n * @param {string} ease\n * @param {number} index\n * @param {number} x\n * @param {number} percentatge\n */\n\n\nfunction getTranslationCSS(duration, ease, index, x, percentatge) {\n  var easeCssText = ease !== '' ? \"transition-timing-function: \" + ease + \";\" : '';\n  var durationCssText = duration ? \"transition-duration: \" + duration + \"ms;\" : '';\n  return \"\" + easeCssText + durationCssText + \"transform: \" + translate(index, x, percentatge) + \";\";\n}\n\nfunction cleanContainer(container) {\n  // remove all the elements except the last one as it seems to be old data in the HTML\n  // that's specially useful for dynamic content\n  while (container.childElementCount > 1) {\n    container !== null && container.removeChild(container.lastChild);\n  } // tell that the clean is done\n\n\n  return true;\n}\n\nexport default function slidy(containerDOMEl, options) {\n  var doAfterSlide = options.doAfterSlide,\n      doBeforeSlide = options.doBeforeSlide,\n      ease = options.ease,\n      initialSlide = options.initialSlide,\n      numOfSlides = options.numOfSlides,\n      onNext = options.onNext,\n      onPrev = options.onPrev,\n      slidesDOMEl = options.slidesDOMEl,\n      slideSpeed = options.slideSpeed;\n  var items = options.items; // if frameDOMEl is null, then we do nothing\n\n  if (containerDOMEl === null) return; // initialize some variables\n\n  var index = initialSlide;\n  var isScrolling = false;\n  var transitionEndCallbackActivated = false; // event handling\n\n  var deltaX = 0;\n  var deltaY = 0;\n  var touchOffsetX = 0;\n  var touchOffsetY = 0;\n  /**\n   * translates to a given position in a given time in milliseconds\n   *\n   * @param  {number} duration time in milliseconds for the transistion\n   * @param  {string} ease easing css property\n   * @param  {number} x Number of pixels to fine tuning translation\n   */\n\n  function _translate(duration, ease, x) {\n    if (ease === void 0) {\n      ease = '';\n    }\n\n    if (x === void 0) {\n      x = 0;\n    }\n\n    var percentatge = 100 / numOfSlides;\n    slidesDOMEl.style.cssText = getTranslationCSS(duration, ease, index, x, percentatge);\n  }\n  /**\n   * slide function called by prev, next & touchend\n   *\n   * determine nextIndex and slide to next postion\n   * under restrictions of the defined options\n   *\n   * @param {boolean} direction 'true' for right, 'false' for left\n   */\n\n\n  function slide(direction) {\n    var movement = direction === true ? 1 : -1; // calculate the nextIndex according to the movement\n\n    var nextIndex = index + 1 * movement; // nextIndex should be between 0 and items minus 1\n\n    nextIndex = clampNumber(nextIndex, 0, items - 1);\n    goTo(nextIndex);\n  }\n\n  function onTransitionEnd() {\n    if (transitionEndCallbackActivated === true) {\n      _translate(0);\n\n      transitionEndCallbackActivated = false;\n    }\n  }\n\n  function onTouchstart(e) {\n    var coords = getTouchCoordinatesFromEvent(e);\n    isScrolling = undefined;\n    touchOffsetX = coords.pageX;\n    touchOffsetY = coords.pageY;\n  }\n\n  function onTouchmove(e) {\n    // ensure swiping with one touch and not pinching\n    if (e.touches.length > 1 || e.scale && e.scale !== 1) return;\n    var coords = getTouchCoordinatesFromEvent(e);\n    deltaX = coords.pageX - touchOffsetX;\n    deltaY = coords.pageY - touchOffsetY;\n\n    if (typeof isScrolling === 'undefined') {\n      isScrolling = abs(deltaX) < abs(deltaY);\n      if (!isScrolling) document.ontouchmove = function (e) {\n        return e.preventDefault();\n      };\n      return;\n    }\n\n    if (!isScrolling) {\n      e.preventDefault();\n\n      _translate(0, LINEAR_ANIMATION, deltaX * -1);\n    }\n  }\n\n  function onTouchend() {\n    // hack the document to block scroll\n    document.ontouchmove = function () {\n      return true;\n    };\n\n    if (!isScrolling) {\n      /**\n       * is valid if:\n       * -> swipe distance is greater than the specified valid swipe distance\n       * -> swipe distance is more then a third of the swipe area\n       * @isValidSlide {Boolean}\n       */\n      var isValid = abs(deltaX) > VALID_SWIPE_DISTANCE;\n      /**\n       * is out of bounds if:\n       * -> index is 0 and deltaX is greater than 0\n       * -> index is the last slide and deltaX is smaller than 0\n       * @isOutOfBounds {Boolean}\n       */\n\n      var direction = deltaX < 0;\n      var isOutOfBounds = direction === false && index === 0 || direction === true && index === items - 1;\n      /**\n       * If the swipe is valid and we're not out of bounds\n       * -> Slide to the direction\n       * otherwise: go back to the previous slide with a linear animation\n       */\n\n      isValid === true && isOutOfBounds === false ? slide(direction) : _translate(slideSpeed, LINEAR_ANIMATION);\n    } // reset variables with the initial values\n\n\n    deltaX = deltaY = touchOffsetX = touchOffsetY = 0;\n  }\n  /**\n   * public\n   * setup function\n   */\n\n\n  function _setup() {\n    slidesDOMEl.addEventListener(TRANSITION_END, onTransitionEnd);\n    containerDOMEl.addEventListener('touchstart', onTouchstart, EVENT_OPTIONS);\n    containerDOMEl.addEventListener('touchmove', onTouchmove, EVENT_OPTIONS);\n    containerDOMEl.addEventListener('touchend', onTouchend, EVENT_OPTIONS);\n\n    if (index !== 0) {\n      _translate(0);\n    }\n  }\n  /**\n   * public\n   * clean content of the slider\n   */\n\n\n  function clean() {\n    return cleanContainer(slidesDOMEl);\n  }\n  /**\n   * public\n   * @param {number} nextIndex Index number to go to\n   */\n\n\n  function goTo(nextIndex) {\n    // if the nextIndex and the current is the same, we don't need to do the slide\n    if (nextIndex === index) return; // if the nextIndex is possible according to number of items, then use it\n\n    if (nextIndex <= items) {\n      // execute the callback from the options before sliding\n      doBeforeSlide({\n        currentSlide: index,\n        nextSlide: nextIndex\n      }); // execute the internal callback\n\n      nextIndex > index ? onNext(nextIndex) : onPrev(nextIndex);\n      index = nextIndex;\n    } // translate to the next index by a defined duration and ease function\n\n\n    _translate(slideSpeed, ease); // execute the callback from the options after sliding\n\n\n    slidesDOMEl.addEventListener(TRANSITION_END, function cb(e) {\n      doAfterSlide({\n        currentSlide: index\n      });\n      e.currentTarget.removeEventListener(e.type, cb);\n    });\n  }\n  /**\n   * public\n   * prev function: called on clickhandler\n   */\n\n\n  function prev(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    slide(false);\n  }\n  /**\n   * public\n   * next function: called on clickhandler\n   */\n\n\n  function next(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    slide(true);\n  }\n  /**\n   * public\n   * @param {number} newItems Number of items in the slider for dynamic content\n   */\n\n\n  function updateItems(newItems) {\n    items = newItems;\n  }\n  /**\n   * public\n   * destroy function: called to gracefully destroy the slidy instance\n   */\n\n\n  function destroy() {\n    // remove all touch listeners\n    containerDOMEl.removeEventListener('touchstart', onTouchstart, EVENT_OPTIONS);\n    containerDOMEl.removeEventListener('touchmove', onTouchmove, EVENT_OPTIONS);\n    containerDOMEl.removeEventListener('touchend', onTouchend, EVENT_OPTIONS); // remove transition listeners\n\n    slidesDOMEl.removeEventListener(TRANSITION_END, onTransitionEnd);\n  } // trigger initial setup\n\n\n  _setup(); // expose public api\n\n\n  return {\n    clean: clean,\n    destroy: destroy,\n    goTo: goTo,\n    next: next,\n    prev: prev,\n    slide: slide,\n    updateItems: updateItems\n  };\n}"]},"metadata":{},"sourceType":"module"}